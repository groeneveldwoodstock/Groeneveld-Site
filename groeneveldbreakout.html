<!DOCTYPE html>
<link rel="stylesheet" href="stylesheet.css">
<a href="index.html">‚Üê Back to Home</a>
<html>
<head>
  <title>Basic Breakout HTML Game</title>
  <meta charset="UTF-8">
  <style>
  html, body {
    height: 100%;
    margin: 0;
  }

  body {
    font-family: 'Arial', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    text-align: center;
  }

  a {
    display: inline-block;
    padding: 10px 15px;
        margin-bottom: 20px;
        background-color: #fff;
        color: #000;
        text-decoration: none;
        border-radius: 5px;
        border: 1px solid #ccc;
    }
    
    h1 {
        color: #fff;
        margin-bottom: 20px;
    }

  a:hover {
    background-color: #f0f0f0;
  }

  canvas {
    background-color: darkgrey;
    margin-top: 20px;
  }

  .instructions {
    color: #fff;
    margin-top: 20px;
    font-size: 14px;
  }
  </style>
<h1>Welcome to Breakout Game!</h1>
<div class="instructions">
  Use the <strong>Spacebar</strong> to start the game or serve a new ball.<br>
  Use the <strong>Left</strong> and <strong>Right Arrow Keys</strong> to move the paddle.
</div>
</head>
<body>
<canvas width="400" height="500" id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');
let score = 0;
const brickScores = {
  'R': 20,
  'O': 15,
  'G': 10,
  'Y': 5
};

// Update score when brick is hit
function updateScore(colorCode) {
  score += brickScores[colorCode];
}
// each row is 14 bricks long. the level consists of 6 blank rows then 8 rows
// of 4 colors: red, orange, green, and yellow
const level1 = [
  [],
  [],
  [],
  [],
  [],
  [],
  ['R','R','R','R','R','R','R','R','R','R','R','R','R','R'],
  ['R','R','R','R','R','R','R','R','R','R','R','R','R','R'],
  ['O','O','O','O','O','O','O','O','O','O','O','O','O','O'],
  ['O','O','O','O','O','O','O','O','O','O','O','O','O','O'],
  ['G','G','G','G','G','G','G','G','G','G','G','G','G','G'],
  ['G','G','G','G','G','G','G','G','G','G','G','G','G','G'],
  ['Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y'],
  ['Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y']
];

// create a mapping between color short code (R, O, G, Y) and color name
const colorMap = {
  'R': 'red',
  'O': 'orange',
  'G': 'green',
  'Y': 'yellow'
};

// --- Audio helpers (lazy AudioContext) ---
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playShootSound(delay = 0) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime + delay;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(700, now);
    o.frequency.exponentialRampToValueAtTime(450, now + 0.06);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + 0.18);
  } catch(e) {}
}

function playPopSound(delay = 0) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime + delay;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle';
    const startFreq = 1100 + Math.random() * 400;
    o.frequency.setValueAtTime(startFreq, now);
    o.frequency.exponentialRampToValueAtTime(350, now + 0.12 + Math.random() * 0.06);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.45, now + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22 + Math.random() * 0.06);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + 0.26 + Math.random() * 0.06);
  } catch(e) {}
}

function playPaddleSound(delay = 0) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime + delay;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(220, now);
    o.frequency.exponentialRampToValueAtTime(120, now + 0.06);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.22, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + 0.14);
  } catch(e) {}
}

// --- 3D drawing helpers ---
function drawBallVisual(b) {
  const cx = b.x + b.width / 2;
  const cy = b.y + b.height / 2;
  const r = Math.max(b.width, b.height);

  const grad = context.createRadialGradient(cx - r * 0.3, cy - r * 0.3, r * 0.1, cx, cy, r);
  grad.addColorStop(0, 'rgba(255,255,255,0.95)');
  grad.addColorStop(0.25, 'white');
  grad.addColorStop(0.4, 'lightgray');
  grad.addColorStop(1, 'rgba(0,0,0,0.25)');

  context.beginPath();
  context.arc(cx, cy, r, 0, Math.PI * 2);
  context.fillStyle = grad;
  context.fill();

  context.lineWidth = Math.max(1, r * 0.08);
  context.strokeStyle = 'rgba(0,0,0,0.18)';
  context.stroke();
}

function roundRectPath(x, y, w, h, r) {
  const path = new Path2D();
  const rad = Math.min(r, w/2, h/2);
  path.moveTo(x + rad, y);
  path.arcTo(x + w, y, x + w, y + h, rad);
  path.arcTo(x + w, y + h, x, y + h, rad);
  path.arcTo(x, y + h, x, y, rad);
  path.arcTo(x, y, x + w, y, rad);
  path.closePath();
  return path;
}

function drawBrickVisual(brick) {
  const x = brick.x;
  const y = brick.y;
  const w = brick.width;
  const h = brick.height;
  const grad = context.createLinearGradient(x, y, x + w, y + h);
  grad.addColorStop(0, 'rgba(255,255,255,0.6)');
  grad.addColorStop(0.15, brick.color);
  grad.addColorStop(1, 'rgba(0,0,0,0.25)');

  const p = roundRectPath(x + 0.5, y + 0.5, w - 1, h - 1, 3);
  context.fillStyle = grad;
  context.fill(p);

  context.lineWidth = 1;
  context.strokeStyle = 'rgba(0,0,0,0.2)';
  context.stroke(p);
}

function drawPaddleVisual(p) {
  const x = p.x;
  const y = p.y;
  const w = p.width;
  const h = p.height;
  const grad = context.createLinearGradient(x, y, x + w, y + h);
  grad.addColorStop(0, '#bfefff');
  grad.addColorStop(0.5, '#00d1ff');
  grad.addColorStop(1, 'rgba(0,0,0,0.2)');

  const pth = roundRectPath(x, y, w, h, 6);
  context.fillStyle = grad;
  context.fill(pth);
  context.lineWidth = 1;
  context.strokeStyle = 'rgba(0,0,0,0.22)';
  context.stroke(pth);
}

// build multiple level layouts (derived from level1)
function buildLevels() {
  // level1 is the base layout
  const level2 = level1.map(row => {
    if (!row || row.length === 0) return [];
    // shift row to the right by 2
    const shift = 2;
    const newRow = [];
    for (let i = 0; i < row.length; i++) {
      newRow[(i + shift) % row.length] = row[i];
    }
    return newRow;
  });

  // level3: vertical stripes (cycle colors across columns)
  const colors = ['R','O','G','Y'];
  const level3 = level1.map((row, rIndex) => {
    if (!row || row.length === 0) return [];
    const newRow = [];
    for (let c = 0; c < row.length; c++) {
      newRow[c] = colors[c % colors.length];
    }
    return newRow;
  });

  return [level1, level2, level3];
}

const levels = buildLevels();
let currentLevelIndex = 0;
let levelCleared = false;
let levelClearTimer = 0;
const levelClearDuration = 120; // frames (~2 seconds at 60fps)

// use a 2px gap between each brick
const brickGap = 2;
const brickWidth = 25;
const brickHeight = 12;

// the wall width takes up the remaining space of the canvas width. with 14 bricks
// and 13 2px gaps between them, thats: 400 - (14 * 25 + 2 * 13) = 24px. so each
// wall will be 12px
const wallSize = 12;
let bricks = [];
// Initialize score display and balls remaining
const scoreDisplay = {
  x: 10,
  y: 25,
  fontSize: 16
};

// how many balls (lives) the player has
let ballsRemaining = 4;
const ballsDisplay = {
  x: 120,
  y: 25,
  fontSize: 16
};

// high score persisted across sessions
let highScore = parseInt(localStorage.getItem('breakoutHighScore')) || 0;

let gameOver = false;

// create bricks from level1 configuration (so we can reset later)
function createBricks() {
  bricks = [];
  const layout = levels[currentLevelIndex];
  for (let row = 0; row < layout.length; row++) {
    for (let col = 0; col < layout[row].length; col++) {
      const colorCode = layout[row][col];
      if (!colorCode) continue;

      bricks.push({
        x: wallSize + (brickWidth + brickGap) * col,
        y: wallSize + (brickHeight + brickGap) * row,
        color: colorMap[colorCode],
        code: colorCode,
        width: brickWidth,
        height: brickHeight
      });
    }
  }
}

// populate bricks initially
createBricks();
// (bricks are created by createBricks())

const paddle = {
  // place the paddle horizontally in the middle of the screen
  x: canvas.width / 2 - brickWidth / 3,
  y: 440,
  width: brickWidth,
  height: brickHeight,

  // paddle x velocity
  dx: 0
};

const ball = {
  x: 130,
  y: 260,
  width: 5,
  height: 5,

  // how fast the ball should go in either the x or y direction
  speed: 2,

  // ball velocity
  dx: 0,
  dy: 0
};

// check for collision between two objects using axis-aligned bounding box (AABB)
// @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
function collides(obj1, obj2) {
  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}

// game loop
function loop() {
  requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  // draw score and high score
  context.fillStyle = 'white';
  context.font = `${scoreDisplay.fontSize}px Arial`;
  context.fillText('Score: ' + score, scoreDisplay.x, scoreDisplay.y);
  context.fillText('High: ' + highScore, canvas.width - 110, scoreDisplay.y);

  // draw ball icons for remaining balls
  const ballIconRadius = 6;
  const startX = ballsDisplay.x;
  const iconY = ballsDisplay.y - 8;
  for (let i = 0; i < ballsRemaining; i++) {
    const cx = startX + i * (ballIconRadius * 2 + 6);
    context.beginPath();
    context.fillStyle = 'white';
    context.arc(cx, iconY, ballIconRadius, 0, Math.PI * 2);
    context.fill();
  }

  // show Level Cleared overlay and pause before advancing
  if (levelCleared) {
    // overlay
    context.fillStyle = 'rgba(0,0,0,0.6)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = 'white';
    context.font = '28px Arial';
    context.fillText('Level Cleared!', canvas.width / 2 - 100, canvas.height / 2 - 10);

    context.font = '16px Arial';
    const secondsLeft = Math.ceil(levelClearTimer / 60);
    context.fillText('Next level starts in ' + secondsLeft + '...', canvas.width / 2 - 110, canvas.height / 2 + 25);

    // countdown
    levelClearTimer -= 1;
    if (levelClearTimer <= 0) {
      // advance level
      currentLevelIndex = (currentLevelIndex + 1) % levels.length;
      // slightly increase ball speed with level
      ball.speed = 2 + currentLevelIndex * 0.4;

      createBricks();
      // reset ball and pause until player launches
      ball.x = 130;
      ball.y = 260;
      ball.dx = 0;
      ball.dy = 0;

      levelCleared = false;
    }

    return; // skip physics while level-cleared overlay is shown
  }

  // if the player is out of balls, show Game Over overlay and stop updates
  if (gameOver) {
    // ensure high score persisted
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('breakoutHighScore', highScore);
    }

    // semi-transparent overlay
    context.fillStyle = 'rgba(0,0,0,0.6)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Game Over text
    context.fillStyle = 'white';
    context.font = '28px Arial';
    context.fillText('Game Over', canvas.width / 2 - 70, canvas.height / 2 - 10);

    context.font = '18px Arial';
    context.fillText('Score: ' + score, canvas.width / 2 - 50, canvas.height / 2 + 20);
    context.fillText('High Score: ' + highScore, canvas.width / 2 - 70, canvas.height / 2 + 45);
    context.fillText('Press R to restart', canvas.width / 2 - 80, canvas.height / 2 + 80);
    return;
  }

  // move paddle by it's velocity
  paddle.x += paddle.dx;

  // prevent paddle from going through walls
  if (paddle.x < wallSize) {
    paddle.x = wallSize
  }
  else if (paddle.x + brickWidth > canvas.width - wallSize) {
    paddle.x = canvas.width - wallSize - brickWidth;
  }

  // move ball by it's velocity
  ball.x += ball.dx;
  ball.y += ball.dy;

  // prevent ball from going through walls by changing its velocity
  // left & right walls
  if (ball.x < wallSize) {
    ball.x = wallSize;
    ball.dx *= -1;
  }
  else if (ball.x + ball.width > canvas.width - wallSize) {
    ball.x = canvas.width - wallSize - ball.width;
    ball.dx *= -1;
  }
  // top wall
  if (ball.y < wallSize) {
    ball.y = wallSize;
    ball.dy *= -1;
  }

  // reset ball if it goes below the screen (lose a ball)
  if (ball.y > canvas.height) {
    ballsRemaining -= 1;

    ball.x = 130;
    ball.y = 260;
    ball.dx = 0;
    ball.dy = 0;

    if (ballsRemaining <= 0) {
      gameOver = true;
      // update high score immediately when game ends
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('breakoutHighScore', highScore);
      }
    }
  }

  // check to see if ball collides with paddle. if they do change y velocity
  if (collides(ball, paddle)) {
    ball.dy *= -1;

    // move ball above the paddle otherwise the collision will happen again
    // in the next frame
    ball.y = paddle.y - ball.height;
    
    // play paddle hit sound
    playPaddleSound(0);
  }

  // check to see if ball collides with a brick. if it does, remove the brick
  // and change the ball velocity based on the side the brick was hit on
  for (let i = 0; i < bricks.length; i++) {
    const brick = bricks[i];

    if (collides(ball, brick)) {
      // update score based on brick color code
      if (brick.code) {
        updateScore(brick.code);
      }

      // remove brick from the bricks array
      bricks.splice(i, 1);

      // play pop sound when brick is removed
      playPopSound(0);

      // ball is above or below the brick, change y velocity
      // account for the balls speed since it will be inside the brick when it
      // collides
      if (ball.y + ball.height - ball.speed <= brick.y ||
          ball.y >= brick.y + brick.height - ball.speed) {
        ball.dy *= -1;
      }
      // ball is on either side of the brick, change x velocity
      else {
        ball.dx *= -1;
      }

      break;
    }
  }

  // if all bricks are cleared, start the level-cleared sequence (overlay + countdown)
  if (bricks.length === 0 && !levelCleared) {
    levelCleared = true;
    levelClearTimer = levelClearDuration;
  }

  // draw walls
  context.fillStyle = 'lightgrey';
  context.fillRect(0, 0, canvas.width, wallSize);
  context.fillRect(0, 0, wallSize, canvas.height);
  context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

  // draw ball if it's moving
  if (ball.dx || ball.dy) {
    drawBallVisual(ball);
  }

  // draw bricks with 3D style
  bricks.forEach(function(brick) {
    drawBrickVisual(brick);
  });

  // draw paddle
  drawPaddleVisual(paddle);
}

// listen to keyboard events to move the paddle
document.addEventListener('keydown', function(e) {
  // left arrow key
  if (e.which === 37) {
    paddle.dx = -3;
  }
  // right arrow key
  else if (e.which === 39) {
    paddle.dx = 3;
  }

  // space key
  // if the ball is not moving, we can launch the ball using the space key.
  // only allow launching when there are balls remaining and the game is not over.
  if (ball.dx === 0 && ball.dy === 0 && e.which === 32) {
    if (!gameOver && ballsRemaining > 0) {
      ball.dx = ball.speed;
      ball.dy = ball.speed;
    }
  }

  // restart key (R)
  if ((e.key === 'r' || e.key === 'R' || e.which === 82) && gameOver) {
    restartGame();
  }
});

// listen to keyboard events to stop the paddle if key is released
document.addEventListener('keyup', function(e) {
  if (e.which === 37 || e.which === 39) {
    paddle.dx = 0;
  }
});

// restart the game by re-initializing state
function restartGame() {
  // reset score and balls
  score = 0;
  ballsRemaining = 4;
  gameOver = false;

  // reset paddle
  paddle.x = canvas.width / 2 - brickWidth / 3;
  paddle.dx = 0;

  // reset ball
  ball.x = 130;
  ball.y = 260;
  ball.dx = 0;
  ball.dy = 0;

  // rebuild bricks
  createBricks();
}

// start the game
requestAnimationFrame(loop);
</script>
</body>
</html>