<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Burst</title>
    <link rel="stylesheet" href="stylesheet.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23667eea'/><text x='50' y='70' font-size='70' font-weight='bold' fill='white' text-anchor='middle' font-family='Arial, sans-serif'>G</text></svg>" type="image/svg+xml">
    
    <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
    }

    a {
      display: inline-block;
      padding: 10px 15px;
      margin-bottom: 20px;
      background-color: #fff;
      color: #000;
      text-decoration: none;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    h1 {
      color: #fff;
      margin-bottom: 20px;
    }

    a:hover {
      background-color: #f0f0f0;
    }

    canvas {
      background-color: darkgrey;
      margin-top: 20px;
    }

    .instructions {
      color: #fff;
      margin-top: 20px;
      font-size: 14px;
    }
    
    button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #fff;
      color: #000;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      font-family: 'Arial', sans-serif;
    }

    button:hover {
      background-color: #f0f0f0;
    }
    .hud {
      margin-bottom: 6px;
    }
    #scoreDisplay {
      color: darkblue;
      font-size: 18px;
      font-weight: 600;
    }
    #highDisplay {
      color: #4a90e2;
      font-size: 18px;
      font-weight: 600;
      margin-left: 12px;
    }
    </style>
</head>
<body>
<a href="index.html">← Back to Home</a>
<h1>Welcome to Bubble Shooter!</h1>
<div class="instructions">
  Use the <strong>Left</strong> and <strong>Right Arrow Keys</strong> to aim.<br>
  Press <strong>Space</strong> to shoot the current bubble.
</div>
<div class="hud">
  <span id="scoreDisplay">Score: 0</span>
  <span id="highDisplay" style="margin-left:12px">High: 0</span>
</div>
<canvas width="271" height="392" id="game"></canvas>
<button id="restartBtn" type="button">Restart Game</button>
<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');


// size of each grid cell (also the diameter of each bubble)
const grid = 32;

// each even row is 8 bubbles long and each odd row is 7 bubbles long.
// define multiple level layouts (arrays of rows using color codes)
const levels = [
  // Level 1 (original)
  [
    ['R','R','Y','Y','B','B','G','G'],
    ['R','R','Y','Y','B','B','G'],
    ['B','B','G','G','R','R','Y','Y'],
    ['B','G','G','R','R','Y','Y']
  ],
  // Level 2 (shifted colors)
  [
    ['G','G','R','R','Y','Y','B','B'],
    ['G','G','R','R','Y','Y','B'],
    ['R','R','Y','Y','B','B','G','G'],
    ['R','Y','G','G','R','R','Y']
  ],
  // Level 3 (checker-ish)
  [
    ['R','G','R','G','R','G','R','G'],
    ['G','R','G','R','G','R','G'],
    ['B','Y','B','Y','B','Y','B','Y'],
    ['Y','B','Y','B','Y','B','Y']
  ],
  // Level 4 (sparser)
  [
    ['R',null,'Y',null,'B',null,'G','G'],
    [null,'R',null,'Y',null,'B','G'],
    ['B',null,'G',null,'R',null,'Y','Y'],
    [null,'G',null,'R',null,'Y','Y']
  ],
  // Level 5 (single-color rows)
  [
    ['R','R','R','R','R','R','R','R'],
    ['G','G','G','G','G','G','G'],
    ['B','B','B','B','B','B','B','B'],
    ['Y','Y','Y','Y','Y','Y','Y']
  ]
];

let currentLevel = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('bubbleHighScore')) || 0;
let levelComplete = false;
let levelCompleteTimer = 0;
const levelCompleteDuration = 120; // frames (~2 seconds at 60fps)

// scoring values by color name
const scoreValues = {
  'green': 1,
  'red': 2,
  'yellow': 3,
  'blue': 4
};

// score display settings (match breakout style)
const scoreDisplay = {
  x: 10,
  y: 25,
  fontSize: 16
};

// create a mapping between color short code (R, G, B, Y) and color name
const colorMap = {
  'R': 'red',
  'G': 'green',
  'B': 'blue',
  'Y': 'yellow'
};
const colors = Object.values(colorMap);

// use a 1px gap between each bubble
const bubbleGap = 1;

// the size of the outer walls for the game
const wallSize = 4;
const bubbles = [];
let particles = [];
// audio
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playShootSound(delay = 0) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime + delay;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(900, now);
    o.frequency.exponentialRampToValueAtTime(600, now + 0.08);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.25, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + 0.2);
  } catch (e) {
    // ignore audio errors
  }
}

function playPopSound(delay = 0) {
  try {
    ensureAudio();
    const now = audioCtx.currentTime + delay;
    // short noise-ish pop using oscillator with fast decay
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle';
    const startFreq = 1200 + Math.random() * 600;
    o.frequency.setValueAtTime(startFreq, now);
    o.frequency.exponentialRampToValueAtTime(300, now + 0.12 + Math.random() * 0.06);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.5, now + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.22 + Math.random() * 0.06);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + 0.26 + Math.random() * 0.06);
  } catch (e) {
    // ignore
  }
}

// helper function to convert deg to radians
function degToRad(deg) {
  return (deg * Math.PI) / 180;
}

// rotate a point by an angle
function rotatePoint(x, y, angle) {
  let sin = Math.sin(angle);
  let cos = Math.cos(angle);

  return {
    x: x * cos - y * sin,
    y: x * sin + y * cos
  };
}

// get a random integer between the range of [min,max]
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);

  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// get the distance between two points
function getDistance(obj1, obj2) {
  const distX = obj1.x - obj2.x;
  const distY = obj1.y - obj2.y;
  return Math.sqrt(distX * distX + distY * distY);
}

// check for collision between two circles
function collides(obj1, obj2) {
  return getDistance(obj1, obj2) < obj1.radius + obj2.radius;
}

// find the closest bubbles that collide with the object
function getClosestBubble(obj, activeState = false) {
  const closestBubbles = bubbles
    .filter(bubble => bubble.active == activeState && collides(obj, bubble));

  if (!closestBubbles.length) {
    return;
  }

  return closestBubbles
    // turn the array of bubbles into an array of distances
    .map(bubble => {
      return {
        distance: getDistance(obj, bubble),
        bubble
      }
    })
    .sort((a, b) => a.distance - b.distance)[0].bubble;
}

// create the bubble grid bubble. passing a color will create
// an active bubble
function createBubble(x, y, color) {
  const row = Math.floor(y / grid);
  const col = Math.floor(x / grid);

  // bubbles on odd rows need to start half-way on the grid
  const startX = row % 2 === 0 ? 0 : 0.5 * grid;

  // because we are drawing circles we need the x/y position
  // to be the center of the circle instead of the top-left
  // corner like you would for a square
  const center = grid / 2;

  bubbles.push({
    x: wallSize + (grid + bubbleGap) * col + startX + center,

    // the bubbles are closer on the y axis so we subtract 4 on every
    // row
    y: wallSize + (grid + bubbleGap - 4) * row + center,

    radius: grid / 2,
    color: color,
    active: color ? true : false
  });
}

// get all bubbles that touch the passed in bubble
function getNeighbors(bubble) {
  const neighbors = [];

  // check each of the 6 directions by "moving" the bubble by a full
  const dirs = [
    // right
    rotatePoint(grid, 0, 0),
    // up-right
    rotatePoint(grid, 0, degToRad(60)),
    // up-left
    rotatePoint(grid, 0, degToRad(120)),
    // left
    rotatePoint(grid, 0, degToRad(180)),
    // down-left
    rotatePoint(grid, 0, degToRad(240)),
    // down-right
    rotatePoint(grid, 0, degToRad(300))
  ];

  for (let i = 0; i < dirs.length; i++) {
    const dir = dirs[i];

    const newBubble = {
      x: bubble.x + dir.x,
      y: bubble.y + dir.y,
      radius: bubble.radius
    };
    const neighbor = getClosestBubble(newBubble, true);
    if (neighbor && neighbor !== bubble && !neighbors.includes(neighbor)) {
      neighbors.push(neighbor);
    }
  }

  return neighbors;
}

// remove bubbles that create a match of 3 colors
function removeMatch(targetBubble) {
  const matches = [targetBubble];

  bubbles.forEach(bubble => bubble.processed = false);
  targetBubble.processed = true;

  // loop over the neighbors of matching colors for more matches
  let neighbors = getNeighbors(targetBubble);
  for (let i = 0; i < neighbors.length; i++) {
    let neighbor = neighbors[i];

    if (!neighbor.processed) {
      neighbor.processed = true;

      if (neighbor.color === targetBubble.color) {
        matches.push(neighbor);
        neighbors = neighbors.concat(getNeighbors(neighbor));
      }
    }
  }

  if (matches.length >= 3) {
    matches.forEach(bubble => {
      bubble.active = false;
    });

    // award points based on color for each bubble in the match
    let points = 0;
    matches.forEach(b => {
      const v = scoreValues[b.color] || 0;
      points += v;
    });

    score += points;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('bubbleHighScore', highScore);
    }
    // play a pop sound for each removed bubble with tiny stagger
    for (let i = 0; i < matches.length; i++) {
      playPopSound(i * 0.02);
    }
  }
}

// make any floating bubbles (bubbles that don't have a bubble chain
// that touch the ceiling) drop down the screen
function dropFloatingBubbles() {
  const activeBubbles = bubbles.filter(bubble => bubble.active);
  activeBubbles.forEach(bubble => bubble.processed = false);

  // start at the bubbles that touch the ceiling
  let neighbors = activeBubbles
    .filter(bubble => bubble.y - grid <= wallSize);

  // process all bubbles that form a chain with the ceiling bubbles
  for (let i = 0; i < neighbors.length; i++) {
    let neighbor = neighbors[i];

    if (!neighbor.processed) {
      neighbor.processed = true;
      neighbors = neighbors.concat(getNeighbors(neighbor));
    }
  }

  // any bubble that is not processed doesn't touch the ceiling
  activeBubbles
    .filter(bubble => !bubble.processed)
    .forEach(bubble => {
      bubble.active = false;
      // create a particle bubble that falls down the screen
      particles.push({
        x: bubble.x,
        y: bubble.y,
        color: bubble.color,
        radius: bubble.radius,
        active: true
      });
    });
  // play a pop sound for each dropped bubble (staggered)
  const dropped = particles.length;
  for (let i = 0; i < dropped; i++) {
    playPopSound(i * 0.02);
  }
}

// draw a bubble with a soft radial highlight to give a 3D look
function drawBubbleVisual(bubble) {
  const x = bubble.x;
  const y = bubble.y;
  const r = bubble.radius;

  // main radial gradient: highlight offset slightly toward the top-left
  const grad = context.createRadialGradient(x - r * 0.3, y - r * 0.3, r * 0.1, x, y, r);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.25, bubble.color);
  grad.addColorStop(1, 'rgba(0,0,0,0.25)');

  context.beginPath();
  context.arc(x, y, r, 0, Math.PI * 2);
  context.fillStyle = grad;
  context.fill();

  // soft rim / shadow for depth
  context.lineWidth = Math.max(1, r * 0.06);
  context.strokeStyle = 'rgba(0,0,0,0.15)';
  context.stroke();

  // small glossy highlight ellipse
  context.beginPath();
  context.ellipse(x - r * 0.35, y - r * 0.35, r * 0.45, r * 0.28, -0.4, 0, Math.PI * 2);
  context.fillStyle = 'rgba(255,255,255,0.55)';
  context.fill();
}

// function to load the current level into the bubbles array
function loadLevel(index = currentLevel) {
  console.log('loadLevel called', index);
  bubbles.length = 0;
  particles.length = 0;

  const layout = levels[index];
  if (!layout) {
    console.warn('loadLevel: layout undefined for index', index);
    // fall back to first level if index is invalid
    currentLevel = 0;
    return loadLevel(0);
  }
  console.log('loadLevel: layout length=', layout.length);
  // count how many colored entries are present in the layout (for diagnostics)
  let colorEntries = 0;
  for (let r = 0; r < layout.length; r++) {
    for (let c = 0; c < (r % 2 === 0 ? 8 : 7); c++) {
      if (layout[r] && layout[r][c]) colorEntries++;
    }
  }
  console.log('loadLevel: color entries=', colorEntries);
  for (let row = 0; row < 10; row++) {
    for (let col = 0; col < (row % 2 === 0 ? 8 : 7); col++) {
      const colorCode = layout[row]?.[col];
      const color = colorCode ? colorMap[colorCode] : undefined;
      createBubble(col * grid, row * grid, color);
    }
  }
  // If the loaded layout produced zero active bubbles, find the first non-empty level and load it instead
  const activeCount = bubbles.filter(b => b.active).length;
  console.log('loadLevel result', index, 'bubbles.length=', bubbles.length, 'activeCount=', activeCount);
  // log a few bubble positions/colors for quick inspection
  console.log('sample bubbles:', bubbles.slice(0, 12).map(b => ({x: b.x, y: b.y, active: b.active, color: b.color})));
  if (activeCount === 0) {
    for (let i = 0; i < levels.length; i++) {
      const lvl = levels[i];
      let hasColor = false;
      for (let r = 0; r < lvl.length; r++) {
        for (let c = 0; c < (r % 2 === 0 ? 8 : 7); c++) {
          if (lvl[r] && lvl[r][c]) { hasColor = true; break; }
        }
        if (hasColor) break;
      }
      if (hasColor) {
        console.log('loadLevel found first non-empty level', i);
        currentLevel = i;
        return loadLevel(i);
      }
    }
  }

  // reset level-complete state and timer so the new level starts normally
  levelComplete = false;
  levelCompleteTimer = 0;

  // reset the shooter to the starting position
  getNewBubble();
  shootDeg = 0;
  shootDir = 0;
}

  // initially load the first level (moved below so curBubble exists)

const curBubblePos = {
  // place the current bubble horizontally in the middle of the screen
  x: canvas.width / 2,
  y: canvas.height - grid * 1.5
};
const curBubble = {
  x: curBubblePos.x,
  y: curBubblePos.y,
  color: 'red',
  radius: grid / 2,  // a circles radius is half the width (diameter)

  // how fast the bubble should go in either the x or y direction
  speed: 8,

  // bubble velocity
  dx: 0,
  dy: 0
};

// angle (in radians) of the shooting arrow
let shootDeg = 0;

// min/max angle (in radians) of the shooting arrow
const minDeg = degToRad(-60);
const maxDeg = degToRad(60);

// the direction of movement for the arrow (-1 = left, 1 = right)
let shootDir = 0;

// reset the bubble to shoot to the bottom of the screen
function getNewBubble() {
  curBubble.x = curBubblePos.x;
  curBubble.y = curBubblePos.y;
  curBubble.dx = curBubble.dy = 0;

  const randInt = getRandomInt(0, colors.length - 1);
  curBubble.color = colors[randInt];
}

// now that `curBubble` and `getNewBubble` exist, load the initial level
loadLevel(currentLevel);

// restart the game: clear bubbles/particles and refill the grid
function restartGame() {
  // clear arrays in-place to avoid reassigning the original constants
  bubbles.length = 0;
  particles.length = 0;

  // reset score and level, then load first level
  score = 0;
  currentLevel = 0;
  // ensure level flags reset
  levelComplete = false;
  levelCompleteTimer = 0;
  loadLevel(currentLevel);

  // reset current bubble and controls
  getNewBubble();
  shootDeg = 0;
  shootDir = 0;

  // remove focus from the restart button so Space will shoot, not click the button
  const btn = document.getElementById('restartBtn');
  if (btn && typeof btn.blur === 'function') btn.blur();
}

// wire restart button
document.getElementById('restartBtn').addEventListener('click', restartGame);

// handle collision between the current bubble and another bubble
function handleCollision(bubble) {
  bubble.color = curBubble.color;
  bubble.active = true;
  getNewBubble();
  removeMatch(bubble);
  dropFloatingBubbles();
}

// game loop
function loop() {
  requestAnimationFrame(loop);
  context.clearRect(0,0,canvas.width,canvas.height);

  // HUD is handled by DOM above the canvas; do not draw score on canvas

  // update DOM HUD (keeps score visible if canvas text is not showing)
  const scoreEl = document.getElementById('scoreDisplay');
  const highEl = document.getElementById('highDisplay');
  if (scoreEl) scoreEl.textContent = 'Score: ' + score;
  if (highEl) highEl.textContent = 'High: ' + highScore;

  // if level complete, show overlay and countdown
  if (levelComplete) {
    context.fillStyle = 'rgba(0,0,0,0.6)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = 'white';
    context.font = '24px Arial';
    context.fillText('Level Cleared!', canvas.width / 2 - 90, canvas.height / 2 - 20);

    context.font = '16px Arial';
    const secondsLeft = Math.ceil(levelCompleteTimer / 60);
    context.fillText('Next level in ' + secondsLeft + '...', canvas.width / 2 - 80, canvas.height / 2 + 20);

    levelCompleteTimer -= 1;
    if (levelCompleteTimer <= 0) {
      currentLevel = (currentLevel + 1) % levels.length;
      loadLevel(currentLevel);
    }

    return;
  }

  // move the shooting arrow
  shootDeg = shootDeg + degToRad(2) * shootDir;

  // prevent shooting arrow from going below/above min/max
  if (shootDeg < minDeg) {
    shootDeg = minDeg;
  }
  else if (shootDeg > maxDeg) {
    shootDeg = maxDeg
  }

  // move current bubble by it's velocity
  curBubble.x += curBubble.dx;
  curBubble.y += curBubble.dy;

  // prevent bubble from going through walls by changing its velocity
  if (curBubble.x - grid / 2 < wallSize) {
    curBubble.x = wallSize + grid / 2;
    curBubble.dx *= -1;
  }
  else if (curBubble.x + grid / 2 > canvas.width - wallSize) {
    curBubble.x = canvas.width - wallSize - grid / 2;
    curBubble.dx *= -1;
  }

  // check to see if bubble collides with the top wall
  if (curBubble.y - grid / 2 < wallSize) {
    // make the closest inactive bubble active
    const closestBubble = getClosestBubble(curBubble);
    handleCollision(closestBubble);
  }

  // check to see if bubble collides with another bubble
  for (let i = 0; i < bubbles.length; i++) {
    const bubble = bubbles[i];

    if (bubble.active && collides(curBubble, bubble)) {
      const closestBubble = getClosestBubble(curBubble);
      if (!closestBubble)  {
        window.alert('Game Over');
        window.location.reload();
      }

      if (closestBubble) {
        handleCollision(closestBubble);
      }
    }
  }

  // move bubble particles
  particles.forEach(particle => {
    particle.y += 8;
  });

  // remove particles that went off the screen
  particles = particles.filter(particles => particles.y < canvas.height - grid / 2);

  // if no active bubbles remain, trigger level complete sequence
  const activeCount = bubbles.filter(b => b.active).length;
  if (activeCount === 0 && !levelComplete) {
    levelComplete = true;
    levelCompleteTimer = levelCompleteDuration;
  }

  // draw walls
  context.fillStyle = 'lightgrey';
  context.fillRect(0, 0, canvas.width, wallSize);
  context.fillRect(0, 0, wallSize, canvas.height);
  context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

  // draw bubbles and particles (use textured/3D visual)
  bubbles.concat(particles).forEach(bubble => {
    if (!bubble.active) return;
    drawBubbleVisual(bubble);
  });

  // draw fire arrow. since we're rotating the canvas we need to save
  // the state and restore it when we're done
  context.save();

  // move to the center of the rotation (the middle of the bubble)
  context.translate(curBubblePos.x, curBubblePos.y);
  context.rotate(shootDeg);

  // move to the top-left corner of or fire arrow
  context.translate(0, -grid / 2 * 4.5);

  // draw arrow ↑
  context.strokeStyle = 'white';
  context.lineWidth = 2;
  context.beginPath();
  context.moveTo(0, 0);
  context.lineTo(0, grid * 2);
  context.moveTo(0, 0);
  context.lineTo(-10, grid * 0.4);
  context.moveTo(0, 0);
  context.lineTo(10, grid * 0.4);
  context.stroke();

  context.restore();

  // draw current bubble (use same 3D visual)
  drawBubbleVisual(curBubble);
}

// listen for keyboard events to move the fire arrow
document.addEventListener('keydown', (e) => {
  if (e.code === 'ArrowLeft') {
    shootDir = -1;
  }
  else if (e.code === 'ArrowRight') {
    shootDir = 1;
  }

  // if the current bubble is not moving we can launch it
  if (e.code === 'Space' &&  curBubble.dx === 0 && curBubble.dy === 0) {
    // convert an angle to x/y
    curBubble.dx = Math.sin(shootDeg) * curBubble.speed;
    curBubble.dy = -Math.cos(shootDeg) * curBubble.speed;
    // play shoot sound
    playShootSound(0);
  }
});

// listen for keyboard events to stop moving the fire arrow if key is
// released
document.addEventListener('keyup', (e) => {
  if (
    // only reset shoot dir if the released key is also the current
    // direction of movement. otherwise if you press down both arrow
    // keys at the same time and then release one of them, the arrow
    // stops moving even though you are still pressing a key
    (e.code === 'ArrowLeft' && shootDir === -1) ||
    (e.code === 'ArrowRight' && shootDir === 1)
  ) {
    shootDir = 0;
  }
});

// start the game
requestAnimationFrame(loop);
</script>
</body>
</html>